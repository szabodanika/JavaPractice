\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[hungarian]{babel}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}
\renewcommand{\lstlistingname}{Kodreszlet}%
\lstset{language=Java,
backgroundcolor=\color[HTML]{ebebeb},
keywordstyle={\bfseries \color[HTML]{5d00ff}},
frame=single,
basicstyle=\footnotesize\ttfamily,
captionpos=b,
tabsize=2,
numbers=left,
aboveskip=2em,
belowskip=1em
}
\usepackage{graphicx}
\usepackage{float}
\restylefloat{table}

\title{%
Java SE 2 \\
\large Java alapok Eclipse kornyezetben}

\author{Szabo Daniel\\daniel.szabo99@outlook.com}

\date{\today}

\begin{document}

\maketitle
\begin{abstract}
Ebben a feladatsorban a Java programozas alapjaival valo ismerkedest fogjuk folytatni az Eclipse integralt fejlesztoi kornyezet (IDE) segitsegevel. A feladatsor az elozo JShell feladatsorban tanult muveletekre epitett ujabb eljarasokat es vezerloszerkezeteket mutat be, a while es for ciklusokat, illetve a tomb adatszerkezetet. A megoldashoz szukseged lesz az Eclipse IDE-re amit mar oran korabban feltelepitetted a szamitogepdre. Ha ez nem tortent meg, az Eclipse hivatalos honlapjan megtalalod a telepitesi utmutatot es szukseges allomanyokat.
\end{abstract}

\newpage

\tableofcontents{}

\newpage

\section{Ciklusok}

\paragraph{Bevezetes}

Ebben a feladatban az if-else vezerlo szerkezet utani legfontosabb vezerlo szerkezet tipussal ismerkedunk meg, a ciklusokkal, illetven annak ket fo fajtajaval, a \lstinline{while} es a \lstinline{for} ciklusokkal.

Ciklusokat eljarasok ismetlesere hasznalunk, ahelyett, hogy ugyanazt az eljarast/parancssort tobbszor egymas utan beirnank a forraskodba. Ha egy ciklus kondicioja \lstinline{true}, azt vegtelen ciklusnak nevezzuk, mert sosem all le, csak akkor ha mi leallitjuk.

\subsection{while ciklus}

A \lstinline{while} ciklus addig ismetli a tartalmazott eljarast amig a megadott kondicio teljesul (\lstinline{true} erteke van). A ciklusbol manualisan \lstinline{break} kulcsszoval lehet kilepni, illetve a ciklus elejere \lstinline{continue} kulcsszoval

\begin{lstlisting}[language=Java, caption=Pelda while ciklus 1: 2717 legkisebb osztojanak megkeresese]
int k = 1;
while (2717 % k != 0) {
    k++;
}
System.out.println("2717 legkisebb osztoja: " + k);
\end{lstlisting}

\begin{lstlisting}[language=Java, caption=Pelda while ciklus 2: 2717 legkisebb osztojanak megkeresese]]
int k = 1;
while (true) {
    if(2717 % k == 0) {
        System.out.println("2717 legkisebb osztoja: " + k);
        break;
    }
}
\end{lstlisting}

\newpage

\subsection{for ciklus}

For ciklusokat olyankor hasznalunk amikor pontosan tudjuk, hanyszor szeretnenk egy eljarast elvegezni, vagy amikor egy adatsor minden elemere szeretnenk egy eljarast lefuttatni, nem pedig egy kiszamithatatlan kondicio alapjan dontjuk el, hogy megegyszer megismeteljuk az eljarast vagy sem. A for es while ciklus egymast teljes mertekbenn tudjak helyettesiteni (lasd: kodreszlet~\ref{lst:while-for}), de minden helyzetben egyertelmuen eldontheto, hogy melyikkel lesz gyorsabb es/vagy egyszerubb megoldanunk egy problemat.

\begin{lstlisting}[language=Java, caption=Pelda for ciklus 1: Szamok kiirasa 0-tol 10-ig]
for(int i = 0; i < 10; i++) {
    System.out.println(i);
}
\end{lstlisting}

\begin{lstlisting}[language=Java, caption=Pelda for ciklus 2: Minden masodik szam kiirasa 20-tol 10-ig]
for(int i = 20; i > 10; i -= 2) {
    System.out.println(i);
}
\end{lstlisting}

\begin{lstlisting}[language=Java, caption=Pelda for ciklus 3: Ido kiirasa precenkent ejfeltol ejfelig]
for(int h = 0; h < 24; h++) {
    for(int m = 0; m < 60; m++) {
       System.out.println("Az ido: " + h + ":" + m);
    }
}
\end{lstlisting}

\begin{lstlisting}[language=Java,label={lst:while-for}, caption=Pelda for ciklus 4: 50 es 80 kozotti 3-al oszthato szamok kiirasa konzolra while es for ciklussal]
for(int i = 50; i < 80; i++) {
    if(i % 3 == 0) {
        System.out.println(i);
    }
}

int i = 50;
while(i < 80) {
    if(i % 3 == 0) {
        System.out.println(i);
    }
    i++;
}
\end{lstlisting}

\subsection{Feladatok}

\subsubsection{Feladat}

Ird ki 0-tol 100-ig a paratlan szamokat \lstinline{while} es \lstinline{for} ciklus segitsegevel.

\subsubsection{Feladat}

Ird ki 0-tol 100-ig 5 szorzatait 3 kulonbozo megoldassal, for ciklus hasznalataval (0, 5, 10 ... 90, 95).

\subsubsection{Feladat}

Keresd meg es ird ki a konzolra 1142617 egesz osztoit.

\subsubsection{Feladat}

Mi tortenik, ha
\begin{itemize}
    \item egy while ciklus kondicioja csak \lstinline{true} vagy \lstinline{false},
    \item egy while ciklus kondicioja egy valtozo, de megsem vesz fel soha \lstinline{false} erteket,
    \item egy vegtelen ciklus utan kodot irsz?
\end{itemize}

\newpage

\subsubsection{Feladat}

Fogalmazd meg, mit csinal a kovetkezo a kovetkezo kodreszlet, majd futtasd le es ellenorizd onmagad.

\begin{lstlisting}[language=Java, caption=Feladat]
String s = "";
while(s.length() < 100) {
    if(s.length() % 2 == 0) {
        s += "L";
    } else {
        s += "A";
    }
}
System.out.print(s);
\end{lstlisting}

\subsubsection{Feladat}

Fogalmazd meg, mit csinal a kovetkezo kodreszlet, majd futtasd le es ellenorizd onmagad.

\begin{lstlisting}[language=Java, caption=Feladat]
for(int x = 0; x < 100; x++) {
    for(int y = 0; y < 100; y++) {
       System.out.print("\t" + x*y);
    }
    System.out.print("\n");
}
\end{lstlisting}

\newpage

\section{Tombok}

\paragraph{Bevezetes}

Ebben a feladatban a tombokkel ismerkedunk meg. Gyakran nem egy vagy ket valtozoval dolgozunk, hanem tobb szaz vagy akar tobb millio adattal. Ilyenkor az adatokat ugynevezett adatszerkezetekbe rendezzuk, amikben az adatokat tudjuk kezelni, feldolgozni. A tomb a legegyszerubb adatszerkezet: egy megadott tipusu elemeket tartalmazo, allando hosszusagu rendezett adatsor. Egy tombben az elemek szamozva vannak, az un. indexek 0-tol kezdodnek.

\subsection{Tomb letrehozasa}

Ha olyan tombot hozunk letre aminek az ertekeit mar most (a program irasakor) ismerjuk, azokat egyszeruen felsorolassal megadhatjuk:

\begin{lstlisting}[language=Java, caption=Tomb letrehozas 1. modszere]
int[] lottoSzamok = {12, 41, 2, 51, 3, 12};

String[] nevek = {"Kis Juliska", "Nagy Jancsika", "Kozepes Jolika"};
\end{lstlisting}

\begin{lstlisting}[language=Java, caption=Tomb letrehozas 2. modszere]
int[] lottoSzamok = new int[] {12, 41, 2, 51, 3, 12};

String[] nevek = new String[] {"Kis Juliska",
    "Nagy Jancsika", "Kozepes Jolika"};
\end{lstlisting}

Ha nem szeretnenk vagy nem tudjuk a tomb elemeit rogton megadni es majd csak kesobb szeretnenk feltolteni ertekekkel, megadhatjuk a tomb hosszat es a tomb a tipus alapertekevel lesz feltoltve.

\begin{lstlisting}[language=Java, caption=Tomb letrehozas 3. modszere]
int[] lottoSzamok = new int[6]; // -> {0, 0, 0, 0, 0, 0}

String[] nevek = new String[3]; // -> {null, null, null}
\end{lstlisting}

\begin{lstlisting}[language=Java, caption=Tomb elemeinek elerese indexekkel]
int[] lottoSzamok = new int[] {12, 41, 2, 51, 3, 12};

int elsoLottoSzam = lottoSzamok[0];
int masodikLottoSzam = lottoSzamok[1];
int utolsoLottoSzam = lottoSzamok[5];
\end{lstlisting}

\begin{lstlisting}[language=Java, caption=Tomb hosszanak lekerdezese]
String[] nevsor = new String[] {"Kis Juliska",
    "Nagy Jancsika", "Kozepes Jolika"};

int letszam = nevsor.length;
\end{lstlisting}

\begin{lstlisting}[language=Java, caption=Tomb modositasa]
String[] nevsor = new String[] {"Kis Juliska",
    "Nagy Jancsika", "Kozepes Jolika"};

nevsor[0] = "Kis Jucika";
\end{lstlisting}

Egy tomb hosszat a \lstinline{length} valtozo segitsegevel kerhetjuk le. Figyeljunk oda arra, hogy a \lstinline{String} valtozok eseteben a \lstinline{length()}, ami megadja a karakterlanc hosszat, az egy fuggveny, es a vegere zarojel kerul: \lstinline{"szo".length()}. Tombok eseteben viszont nem teszunk zarojelet, mert ott \lstinline{length} nem egy fuggveny: \lstinline{nevsor.length}.

\begin{lstlisting}[language=Java, caption=Utolso elem indexenek szamolasa]
String[] nevsor = new String[] {"Kis Juliska",
    "Nagy Jancsika", "Kozepes Jolika"};

String utolsoNev = nevsor[nevsor.length - 1];
\end{lstlisting}

\subsection{Feladatok}

\subsubsection{Feladat}

Probalj tombot letrehozni, elemeket megadni, modositani stb. az alabbi adattipusokkal:

\begin{itemize}
    \item \lstinline{boolean}
    \item \lstinline{String}
    \item \lstinline{int}
    \item \lstinline{float}
\end{itemize}

\subsubsection{Feladat}

Mi tortenik, ha

\begin{itemize}
    \item 0 hosszu tombot hozunk letre (es ezt milyen modokon tehetjuk?),
    \item egy \lstinline{String} tombbe \lstinline{int}, \lstinline{int} tombbe \lstinline{float}, vagy \lstinline{float} tombbe \lstinline{int} ertekeket teszunk?
\end{itemize}


\section{Tombok Feldolgozasa Ciklusokkal}

\paragraph{Bevezetes}

Ciklusokat es tomboket nagyon gyakran hasznalunk egyutt, mert sokszor egy egyszeru adatsoron szeretnenk elvegezni egy muveletet minden elemre, peldaul statisztikat szeretnenk szamolni egy szamsorbol. Amikor tombokkel dolgozunk, szinten minden esetben \lstinline{for} ciklust hasznalunk, mert azt kifejezetten ilyen adatszerkezetek kezelesere hoztak letre.

Egy tomb elemeit bejarhatjuk \lstinline{for} ciklussal. Hagyomanyos for ciklus segitsegevel rugalmasan kezelhetjuk a bejarast:
\begin{lstlisting}[language=Java, caption=Tomb elemeinek megjelenitese]
String[] nevek = {"Kis Juliska", "Nagy Jancsika", "Kozepes Jolika"};

for(int i = 0; i < nevek.length; i++) {
    System.out.println(nevek[i]);
}
\end{lstlisting}

Ha egy tombot az elso elemtol az utolsoig egyesevel szeretnenk bejarni, a \lstinline{for-each} ciklus is hasznalhato:
\begin{lstlisting}[language=Java, caption=Tomb elemeinek megjelenitese for-each ciklussal]
String[] nevek = {"Kis Juliska", "Nagy Jancsika", "Kozepes Jolika"};

for(String nev : nevek) {
    System.out.println(nev);
}
\end{lstlisting}


Az egyik leggyakoribb hasznalata a ciklussal valo tomb bejarasnak a statisztikak szamolasa:
\begin{lstlisting}[language=Java, caption=Atlagszamolas for ciklussal]
int[] szamok = {32, 15, 73, 24, 12, 61, 2, 32, 72, 29};

int osszeg = 0;

for(int i = 0; i < szamok.length; i++) {
    osszeg += szamok[i];
}

double atlag = (double) osszeg / szamok.length;
\end{lstlisting}

\newpage

\begin{lstlisting}[language=Java, caption=Atlagszamolas for-each ciklussal]
int[] szamok = {32, 15, 73, 24, 12, 61, 2, 32, 72, 29};

int osszeg = 0;

for(int szam : szamok) {
    osszeg += szam;
}

double atlag = (double) osszeg / szamok.length;
\end{lstlisting}

Extrem ertekek keresese egy nagyon gyakori feladat, figyelmesen olvasd el az alabbi peldakat es probalj meg elvonatkoztatni a konkret problemaktol es megfigyelni az extrem ertek kereses altalanos logikajat.

\begin{lstlisting}[language=Java, caption=Maximum ertek kereses]
int[] szamok = {32, 15, 73, 24, 12, 61, 2, 32, 72, 29};

int max = 0;

for(int szam : szamok) {
    if(szam > max) {
        max = szam;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=Java, caption=Legrovidebb String kereses]
String[] szavak = {"kutya", "macska", "tej",
        "fa", "teherauto", "alma"};

String legrovidebb = szavak[0];

for(String szo : szavak) {
    if(szo.length() < legrovidebb.length()) {
        legrovidebb = szo;
    }
}
\end{lstlisting}

\newpage

\subsection{Feladatok}

\subsubsection{Feladat}

Keszits egy programot, ami kiszamolja az alabbi szamok osszeget:

\begin{lstlisting}[language=Java, caption=Feladat]
int[] szamok = {32, 15, 73, 24, 12, 61, 2, 32, 72, 29};
\end{lstlisting}

\subsubsection{Feladat}

Keszits egy programot, ami megszamolja, hany ertek \lstinline{true} az alabbi tombben:

\begin{lstlisting}[language=Java, caption=Feladat]
boolean[] logikaiErtekek = {true, false, false, true,
        false, true, false, true};
\end{lstlisting}

\subsubsection{Feladat}

Keszits egy programot, ami megkeresi az 50-hez legkozelebb eso szamot az alabbi tombben:

\begin{lstlisting}[language=Java, caption=Feladat]
double[] szamok = {32.2, 15.23, 73.88, 24.2, 12.2,
        61.12, 2.402, 32.1, 72.02, 29.99};
\end{lstlisting}

\subsubsection{Feladat}

A kovetkezo kodreszletben tobb hiba van. Keresd meg a hibakat, gondold at miert nem jo a program ugy ahogy le van irva es javitsd ki oket.

\begin{lstlisting}[language=Java, caption=Feladat]
int szamok = new int[10] {32, 15, 73, 24, 12, 61, 2, 32, 72, 29};

int a = szamok(0);

if(szamok.length() > 5) {
    System.out.println("a = " + a);
}

for { (i = 1; i <= szamok.length(); i++)
    System.out.println(szamok(i));
}
\end{lstlisting}

\end{document}